/**
 * Build CLI script for Claude Code compatibility
 *
 * Generates bin/cli.mjs that supports three modes:
 * 1. Default (no args): MCP stdio proxy to uvx mnemo-mcp
 * 2. Hook subcommand: Execute Claude Code lifecycle hooks
 * 3. Init subcommand: Export memories to CLAUDE.md (upsert section), optionally spawn claude
 */

import * as fs from 'node:fs'

if (!fs.existsSync('bin')) {
  fs.mkdirSync('bin')
}

const cliScript = `#!/usr/bin/env node
/**
 * mnemo-plugin CLI
 *
 * Modes:
 * - No args: MCP stdio proxy (spawns uvx mnemo-mcp)
 * - hook <action>: Execute Claude Code lifecycle hooks
 * - init [--spawn]: Query mnemo-mcp, write/update CLAUDE.md, optionally launch claude
 */
import { spawn, execSync } from 'node:child_process';
import { writeFileSync, readFileSync, existsSync } from 'node:fs';
import { resolve } from 'node:path';

const args = process.argv.slice(2);
const isWindows = process.platform === 'win32';

// Shared: connect to mnemo-mcp and fetch all memories as markdown
async function fetchMemoriesMarkdown() {
  const { Client } = await import('@modelcontextprotocol/sdk/client/index.js');
  const { StdioClientTransport } = await import('@modelcontextprotocol/sdk/client/stdio.js');
  const { CallToolResultSchema } = await import('@modelcontextprotocol/sdk/types.js');

  const transport = new StdioClientTransport({
    command: 'uvx',
    args: ['mnemo-mcp'],
    stderr: 'ignore',
    env: { ...process.env, LOG_LEVEL: 'WARNING' }
  });

  const client = new Client(
    { name: 'mnemo-plugin-cli', version: '0.0.0' },
    { capabilities: {} }
  );

  await client.connect(transport);

  // Fetch stats
  const statsResult = await client.callTool(
    { name: 'memory', arguments: { action: 'stats' } },
    CallToolResultSchema
  );
  const statsText = statsResult.content.find(c => c.type === 'text')?.text;
  const stats = statsText ? JSON.parse(statsText) : { total_memories: 0 };
  const total = stats.total_memories ?? 0;

  let md = '# Mnemo Memory\\n\\n';

  if (total === 0) {
    md += 'No memories stored yet.\\n';
  } else {
    const listResult = await client.callTool(
      { name: 'memory', arguments: { action: 'list', limit: 50 } },
      CallToolResultSchema
    );
    const listText = listResult.content.find(c => c.type === 'text')?.text;
    const listData = listText ? JSON.parse(listText) : { results: [] };
    const results = listData.results ?? [];

    md += '> Auto-generated by mnemo-plugin. ' + total + ' memories found.\\n\\n';

    const grouped = {};
    for (const mem of results) {
      const cat = mem.category || 'general';
      if (!grouped[cat]) grouped[cat] = [];
      grouped[cat].push(mem);
    }

    for (const [category, mems] of Object.entries(grouped)) {
      md += '## ' + category + '\\n\\n';
      for (const mem of mems) {
        const tags = mem.tags?.length ? ' *(' + mem.tags.join(', ') + ')*' : '';
        md += '- ' + mem.content + tags + '\\n';
      }
      md += '\\n';
    }
  }

  await transport.close();
  return md;
}

// Shared: upsert mnemo memory section into CLAUDE.md
function upsertClaudeMd(markdown, outputPath) {
  const BEGIN = '<!-- BEGIN MNEMO MEMORY -->';
  const END = '<!-- END MNEMO MEMORY -->';
  const directive = "System Directive: You have persistent memory via the 'mnemo' MCP server. Start every new session by running mnemo_search for this project. Save user constraints and preferences with mnemo_remember.";
  const section = BEGIN + '\\n' + directive + '\\n\\n' + markdown + END;

  const existing = existsSync(outputPath) ? readFileSync(outputPath, 'utf8') : '';
  let finalContent;

  if (existing.includes(BEGIN)) {
    const start = existing.indexOf(BEGIN);
    const endIdx = existing.indexOf(END);
    if (endIdx !== -1) {
      finalContent = existing.slice(0, start) + section + existing.slice(endIdx + END.length);
    } else {
      finalContent = existing.slice(0, start) + section;
    }
  } else {
    const sep = existing && !existing.endsWith('\\n') ? '\\n' : '';
    finalContent = existing + sep + '\\n' + section + '\\n';
  }

  writeFileSync(outputPath, finalContent, 'utf8');
}

// Init subcommand: export memories to CLAUDE.md
if (args[0] === 'init') {
  const shouldSpawn = args.includes('--spawn');
  const outputPath = resolve(process.cwd(), 'CLAUDE.md');

  console.error('[mnemo] Connecting to mnemo-mcp to export memories...');

  try {
    const markdown = await fetchMemoriesMarkdown();
    upsertClaudeMd(markdown, outputPath);
    console.error('[mnemo] Wrote ' + outputPath);

    if (shouldSpawn) {
      console.error('[mnemo] Spawning claude...');
      const claude = spawn('claude', [], {
        stdio: 'inherit',
        shell: isWindows,
        cwd: process.cwd()
      });

      claude.on('error', (err) => {
        console.error('[mnemo] Failed to start claude:', err.message);
        process.exit(1);
      });

      claude.on('exit', (code) => {
        process.exit(code || 0);
      });
    } else {
      process.exit(0);
    }
  } catch (err) {
    console.error('[mnemo] Init failed:', err.message || err);
    console.error('[mnemo] Make sure mnemo-mcp is available: uv tool install mnemo-mcp');
    process.exit(1);
  }
}
// Hook subcommand
else if (args[0] === 'hook') {
  const action = args[1];
  let input = '';

  // Read hook payload from stdin (non-blocking)
  if (!process.stdin.isTTY) {
    try {
      input = require('node:fs').readFileSync(0, 'utf8');
    } catch {
      // No stdin input
    }
  }

  const payload = input ? JSON.parse(input) : {};

  switch (action) {
    case 'session-start': {
      // Inject memories into CLAUDE.md and output summary to stdout
      const outputPath = resolve(process.cwd(), 'CLAUDE.md');
      try {
        const markdown = await fetchMemoriesMarkdown();
        upsertClaudeMd(markdown, outputPath);
        console.error('[mnemo] Updated ' + outputPath + ' with latest memories');
        // Output directive to stdout so Claude Code may inject into context
        process.stdout.write("System Directive: You have persistent memory via the 'mnemo' MCP server. Use mnemo_search, mnemo_remember, mnemo_forget tools proactively.\\n");
        process.exit(0);
      } catch (err) {
        console.error('[mnemo] Warning: session-start failed:', err.message || err);
        console.error('[mnemo] Make sure mnemo-mcp is available: uv tool install mnemo-mcp');
        process.exit(0); // Non-fatal: allow session to continue
      }
      break;
    }

    case 'stop':
      // No-op: Claude handles memory via MCP tools during session
      process.exit(0);
      break;

    case 'pre-compact':
      // No-op: memories are already persisted in mnemo-mcp
      process.exit(0);
      break;

    default:
      console.error('[mnemo] Unknown hook action:', action);
      console.error('Available: session-start, stop, pre-compact');
      process.exit(2);
  }
} else {
  // Default mode: MCP stdio proxy
  const child = spawn('uvx', ['mnemo-mcp', ...args], {
    stdio: 'inherit',
    shell: isWindows,
  });

  child.on('error', (err) => {
    console.error('Failed to start mnemo-mcp:', err.message);
    console.error('Make sure uv is installed: https://docs.astral.sh/uv/');
    process.exit(1);
  });

  child.on('exit', (code) => {
    process.exit(code || 0);
  });
}
`

fs.writeFileSync('bin/cli.mjs', cliScript)
fs.chmodSync('bin/cli.mjs', 0o755)

console.log('Built bin/cli.mjs')
